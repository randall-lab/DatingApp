@page "/messages"
@using Microsoft.AspNetCore.Authorization
@using Microsoft.EntityFrameworkCore
@using DatingApp.Domain
@using DatingApp.Data
@implements IAsyncDisposable
@inject IDbContextFactory<DatingApp.Data.DatingAppContext> DbFactory

@attribute [Authorize(Roles = "Administrator")]

<PageTitle>Messages Overview</PageTitle>

@* --- DIFFERENT: Class added for CSS sidebar alignment --- *@
<h1 class="welcome-title">Messages Overview</h1>
<hr />

@* --- DIFFERENT: Replaced QuickGrid with a manual loop for card styling --- *@
<div class="messages-container">
    @if (GroupedMessages == null)
    {
        <p><em>Loading conversations...</em></p>
    }
    else if (!GroupedMessages.Any())
    {
        <p class="no-data">No messages found in the system.</p>
    }
    else
    {
        @foreach (var m in GroupedMessages)
        {
            <div class="conversation-card">
                <div class="message-main">
                    <span class="match-id-badge">
                        @m.UserOneName vs @m.UserTwoName
                    </span>

                    <p class="last-message">@m.LastMessageText</p>
                    <span class="message-meta">Last Activity: @m.LastTimestamp.ToString("g")</span>
                </div>

                <div class="message-actions">
                    <a href="@($"/messages/details?matchId={m.MatchId}")" class="btn-action details">Details</a>
                    <a href="@($"/messages/delete/{m.MatchId}")" class="btn-action delete">Delete</a>
                </div>
            </div>
        }
    }
</div>

@code {
    private DatingAppContext context = default!;
    private List<MessageGroup> GroupedMessages = default!;

    protected override async Task OnInitializedAsync()
    {
        context = DbFactory.CreateDbContext();

        // Load grouped messages
        var grouped = await context.Message
            .GroupBy(m => m.MatchId)
            .Select(g => new
            {
                MatchId = g.Key,
                LastMessage = g.OrderByDescending(m => m.Timestamp).First(),
                LastTimestamp = g.Max(m => m.Timestamp)
            })
            .OrderByDescending(x => x.LastTimestamp)
            .ToListAsync();

        // Get all match IDs
        var matchIds = grouped.Select(x => x.MatchId).ToList();
        var matches = await context.Match
            .Where(m => matchIds.Contains(m.MatchId))
            .ToListAsync();

        // Collect all user IDs from those matches
        var userIds = matches.Select(m => m.UserId_One)
                             .Concat(matches.Select(m => m.UserId_Two))
                             .Distinct()
                             .ToList();

        var profiles = await context.Profile
            .Where(p => userIds.Contains(p.UserId))
            .ToListAsync();

        // Build final list
        GroupedMessages = grouped.Select(x =>
        {
            var match = matches.First(m => m.MatchId == x.MatchId);
            var userOne = profiles.FirstOrDefault(p => p.UserId == match.UserId_One);
            var userTwo = profiles.FirstOrDefault(p => p.UserId == match.UserId_Two);

            return new MessageGroup
            {
                MatchId = x.MatchId,
                LastMessageText = x.LastMessage.MessageText,
                LastTimestamp = x.LastTimestamp,
                UserOneName = userOne?.FirstName ?? match.UserId_One,
                UserTwoName = userTwo?.FirstName ?? match.UserId_Two
            };
        }).ToList();
    }

    public async ValueTask DisposeAsync() => await context.DisposeAsync();

    private class MessageGroup
    {
        public int MatchId { get; set; }
        public string? LastMessageText { get; set; }
        public DateTime LastTimestamp { get; set; }
        public string? UserOneName { get; set; }
        public string? UserTwoName { get; set; }
    }

}